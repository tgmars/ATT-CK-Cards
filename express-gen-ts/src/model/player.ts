import {AttackCard, DefenceCard, Card} from './card';
import { mitre } from '..';

export default class Player {
    /**Initialises as player1 and player2. Use /setname in chat to overwrite.*/
    name:string

    /** False for defender, True for attacker */
    role:boolean
    /** Additional role for bot player */
    isBot:boolean
    resources:number
    opponent:boolean

    hand:Array<Card>
    handMaxLength:number = 5
    deck?:Array<Card>

    progress = {'initial-access':true,'execution':false,'persistence':false,'privilege-escalation':false,
                            'defense-evasion':false,'credential-access':false,'discovery':false,
                            'lateral-movement':false,'collection':false,'command-and-control':false,
                            'exfiltration':false,'impact':false}

    persistentProgress = {'initial-access':true,'execution':false,'persistence':false,'privilege-escalation':false,
    'defense-evasion':false,'credential-access':false,'discovery':false,
    'lateral-movement':false,'collection':false,'command-and-control':false,
    'exfiltration':false,'impact':false}

    // mitre:Array<Object>

    /**
     * 
     * @param role Attacker (true) or defender (false)
     * @param isBot Flag for bot players and chatbots
     * @param autogen Should a name be autogenerated?
     * @param name Name to be provided in the event that autogen is false - always required.
     */
    constructor(role:boolean,isBot:boolean,autogen:boolean,name:string,opponent:boolean){
        // this.mitre = mitre
        this.role = role
        this.isBot = isBot
        this.name = (autogen? 'Default-'+(role ? 'attacker':'defender') : name)
        this.hand = []
        this.opponent = opponent
        this.resources = 100
           
    }

    /**
     * Set the players name
     */
    setName(name:string){
        this.name=name
    }

    /** Insert the specified number of attack techniques into the players hand
     * after checking that 
     * @param numToDraw Number of cards to draw
    */
    draw(numToDraw:number):void{
        if((this.hand.length+numToDraw)>this.handMaxLength){
            try {
                throw new RangeError();
            } catch (e) {
                if(e instanceof RangeError){
                    console.error('Index out of range, attempting to draw more cards than the maximum')
                }
            }
        }else{
            for(let i = 0; i<numToDraw; i++){
                let deckIndex = Math.floor(Math.random()*mitre.length)
                //If attacker 
                //TODO Fix - only draws first column the attack belongs to
                if(this.isAttacker()==true){
                    //only draw cards that are in progress object.
                    let tactic = mitre[deckIndex].kill_chain_phases[0].phase_name
                    
                    let tactics:any= Object.keys(this.progress!).filter(k => (this.progress as any)[k])
                    
                    if(tactics.includes(tactic)){
                        let technique = mitre[deckIndex].name
                        let description = mitre[deckIndex].description
                        let mitigatingSources:Array<string> = mitre[deckIndex].x_mitre_data_sources
                    
                        let c = new AttackCard(tactic,technique,description,mitigatingSources)
                        // Draw opponent cards faceup
                        c.faceup = (this.opponent?false:true)
                        this.hand.splice(this.hand.length,0,c)
                    }else{
                        this.generateAttackCard()
                    }


                    
                }
                //If defender
                if(this.isDefender()){
                    let c = this.generateDefenceCard()
                    c.faceup = (this.opponent?false:true)
                    this.hand.splice(this.hand.length,0,c)

                }
            }
        }   
    }

    /** Discard a card from the players hand based off the index in the hand */
    removeCard(i:number){
        this.hand.splice(i,1)
    }

    isAttacker(){
        return(this.role?true:false)
    }

    isDefender(){
        return(!this.role?true:false)
    }

    generateDefenceCard():DefenceCard{
        let deckIndex = Math.floor(Math.random()*mitre.length)
        //Generate a random selection of mitigating Sources
        let mitigatingSources:Array<string> = mitre[deckIndex].x_mitre_data_sources
        let selector = Math.floor(Math.random()*mitigatingSources.length)
        console.log('Defence card generation: selector + '+selector+' : source: '+mitigatingSources)
        return new DefenceCard(mitigatingSources[selector])
    
    }

    /** Generate an attack card and add to the end of the players hand.
     * The attack card will only include techniques from tactics that
     * have been unlocked. 
     */
    generateAttackCard():void{
        let deckIndex = Math.floor(Math.random()*mitre.length)
            if(this.isAttacker()==true){
                //only draw cards that are in progress object.
                let tactic = mitre[deckIndex].kill_chain_phases[0].phase_name
                
                let tactics:any= Object.keys(this.progress!).filter(k => (this.progress as any)[k])
            
                if(tactics.includes(tactic)){
                    let technique = mitre[deckIndex].name
                    let description = mitre[deckIndex].description
                    let mitigatingSources:Array<string> = mitre[deckIndex].x_mitre_data_sources
                
                    let c = new AttackCard(tactic,technique,description,mitigatingSources)
                    // Draw opponent cards facedown
                    c.faceup = (this.opponent?false:true)
                    this.hand.splice(this.hand.length,0,c)
                }else{
                    this.generateAttackCard()
                }
            }
    }

    /** Nope */
    setProgress(tactic:string){
        switch(tactic) { 
            case 'initial-access': { 
                this.progress['initial-access']=false
                this.progress['execution']=true
                this.persistentProgress['execution']=true

                break
            } 
            case 'execution': { 
                this.progress['execution']=false
                this.progress['persistence']=true
                this.persistentProgress['persistence']=true
                break
            } 
            case 'persistence': { 
                this.progress['persistence']=false
                this.progress['privilege-escalation']=true
                this.persistentProgress['privilege-escalation']=true
                break
            }  
            case 'privilege-escalation': { 
                this.progress['persistence']=false
                this.progress['defense-evasion']=true
                this.persistentProgress['defense-evasion']=true
                break
            }  
            case 'defense-evasion': { 
                this.progress['defense-evasion']=false
                this.progress['credential-access']=true
                this.persistentProgress['credential-access']=true
                break
            }
            case 'credential-access': {
                this.progress['credential-access']=false
                this.progress['discovery']=true
                this.persistentProgress['discovery']=true
                break
            }
            case 'discovery': {
                this.progress['discovery']=false
                this.progress['lateral-movement']=true
                this.persistentProgress['lateral-movement']=true
                break
            }
            case 'lateral-movement': {
                this.progress['lateral-movement']=false
                this.progress['collection']=true
                this.persistentProgress['collection']=true
                break
            }
            case 'collection': {
                this.progress['collection']=false
                this.progress['command-and-control']=true
                this.persistentProgress['command-and-control']=true
                break
            }
            case 'command-and-control': {
                this.progress['command-and-control']=false
                this.progress['exfiltration']=true
                this.persistentProgress['exfiltration']=true
                break
            }
            case 'exfiltration': {
                this.progress['exfiltration']=false
                this.progress['impact']=true
                this.persistentProgress['impact']=true
                break

            }
            case 'impact': {
                this.progress['impact']=true
                this.persistentProgress['impact']=true
                break
            }
         } 
        
    }



    display():void{
        console.log('Player name and role: ' + this.name +': '+this.role)
        console.log('Player hand: ' )
        console.log(this.hand)

    }
  


}